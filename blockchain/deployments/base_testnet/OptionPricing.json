{
  "address": "0xc2a33a404e1fd76eddbF841A9327CD0e1BB4353e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_volatilityCap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minOptionPricePercentage",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "isPut",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "strike",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "volatility",
          "type": "uint256"
        }
      ],
      "name": "getOptionPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minOptionPricePercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minOptionPricePercentage",
          "type": "uint256"
        }
      ],
      "name": "updateMinOptionPricePercentage",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_volatilityCap",
          "type": "uint256"
        }
      ],
      "name": "updateVolatilityCap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "volatilityCap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xefdfbc40d765b02be4ecc747cf6eb6f633959c47c23764cb98fcac47a2eb8796",
  "receipt": {
    "to": null,
    "from": "0x6860542E55Fb9292e4c8b478FcEec724d3351C2e",
    "contractAddress": "0xc2a33a404e1fd76eddbF841A9327CD0e1BB4353e",
    "transactionIndex": 4,
    "gasUsed": "2462290",
    "logsBloom": "0x80000000000000000000000000000000000004000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000100000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000004000000000000000000000000000000000000000000000000000000010",
    "blockHash": "0xf35e70eedb8b15e66ebd49a8c5d29b3c21908c1ecb828223d1da19da1b675214",
    "transactionHash": "0xefdfbc40d765b02be4ecc747cf6eb6f633959c47c23764cb98fcac47a2eb8796",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 1395950,
        "transactionHash": "0xefdfbc40d765b02be4ecc747cf6eb6f633959c47c23764cb98fcac47a2eb8796",
        "address": "0xc2a33a404e1fd76eddbF841A9327CD0e1BB4353e",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000006860542e55fb9292e4c8b478fceec724d3351c2e"
        ],
        "data": "0x",
        "logIndex": 7,
        "blockHash": "0xf35e70eedb8b15e66ebd49a8c5d29b3c21908c1ecb828223d1da19da1b675214"
      }
    ],
    "blockNumber": 1395950,
    "cumulativeGasUsed": "2628757",
    "status": 1,
    "byzantium": true
  },
  "args": [
    1000,
    1
  ],
  "numDeployments": 1,
  "solcInputHash": "76abe4e6d02d904aee51326ce50a63f1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_volatilityCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strike\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"name\":\"getOptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOptionPricePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"name\":\"updateMinOptionPricePercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_volatilityCap\",\"type\":\"uint256\"}],\"name\":\"updateVolatilityCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatilityCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getOptionPrice(bool,uint256,uint256,uint256,uint256)\":{\"params\":{\"expiry\":\"expiry timestamp\",\"isPut\":\"is put option\",\"lastPrice\":\"current price\",\"strike\":\"strike price\",\"volatility\":\"volatility\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateMinOptionPricePercentage(uint256)\":{\"params\":{\"_minOptionPricePercentage\":\"the new %\"},\"returns\":{\"_0\":\"whether % was updated\"}},\"updateVolatilityCap(uint256)\":{\"params\":{\"_volatilityCap\":\"the new volatility cap\"},\"returns\":{\"_0\":\"whether volatility cap was updated\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getOptionPrice(bool,uint256,uint256,uint256,uint256)\":{\"notice\":\"computes the option price (with liquidity multiplier)\"},\"updateMinOptionPricePercentage(uint256)\":{\"notice\":\"updates % of the price of asset which is the minimum option price possible\"},\"updateVolatilityCap(uint256)\":{\"notice\":\"updates volatility cap for an option pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/OptionPricing.sol\":\"OptionPricing\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f633a0223d9a1dcccfcf38a64c9de0874dfcbfac0c6941ccf074d63a2ce0e1e\",\"license\":\"MIT\"},\"contracts/OptionPricing.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// Libraries\\r\\nimport { SafeMath } from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport { BlackScholes } from \\\"./libraries/BlackScholes.sol\\\";\\r\\nimport { ABDKMathQuad } from \\\"./libraries/ABDKMathQuad.sol\\\";\\r\\n\\r\\n// Contracts\\r\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n// Interfaces\\r\\nimport { IOptionPricing } from \\\"./interfaces/IOptionPricing.sol\\\";\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\n\\r\\ncontract OptionPricing is Ownable, IOptionPricing {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // The max volatility possible\\r\\n    uint256 public volatilityCap;\\r\\n\\r\\n    // The % of the price of asset which is the minimum option price possible in 1e8 precision\\r\\n    uint256 public minOptionPricePercentage;\\r\\n\\r\\n    constructor(uint256 _volatilityCap, uint256 _minOptionPricePercentage) {\\r\\n        volatilityCap = _volatilityCap;\\r\\n        minOptionPricePercentage = _minOptionPricePercentage;\\r\\n    }\\r\\n\\r\\n    /*---- GOVERNANCE FUNCTIONS ----*/\\r\\n\\r\\n    /// @notice updates volatility cap for an option pool\\r\\n    /// @param _volatilityCap the new volatility cap\\r\\n    /// @return whether volatility cap was updated\\r\\n    function updateVolatilityCap(uint256 _volatilityCap) external onlyOwner returns (bool) {\\r\\n        volatilityCap = _volatilityCap;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice updates % of the price of asset which is the minimum option price possible\\r\\n    /// @param _minOptionPricePercentage the new %\\r\\n    /// @return whether % was updated\\r\\n    function updateMinOptionPricePercentage(uint256 _minOptionPricePercentage) external onlyOwner returns (bool) {\\r\\n        minOptionPricePercentage = _minOptionPricePercentage;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*---- VIEWS ----*/\\r\\n\\r\\n    /**\\r\\n     * @notice computes the option price (with liquidity multiplier)\\r\\n     * @param isPut is put option\\r\\n     * @param expiry expiry timestamp\\r\\n     * @param strike strike price\\r\\n     * @param lastPrice current price\\r\\n     * @param volatility volatility\\r\\n     */\\r\\n    function getOptionPrice(\\r\\n        bool isPut,\\r\\n        uint256 expiry,\\r\\n        uint256 strike,\\r\\n        uint256 lastPrice,\\r\\n        uint256 volatility\\r\\n    ) external view override returns (uint256) {\\r\\n        //uint256 timeToExpiry = expiry.sub(block.timestamp).div(864);\\r\\n        uint256 timeToExpiry = expiry.sub(block.timestamp).mul(100);\\r\\n\\r\\n        uint256 optionPrice = BlackScholes\\r\\n            .calculate(\\r\\n                isPut ? 1 : 0, // 0 - Put, 1 - Call\\r\\n                lastPrice,\\r\\n                strike,\\r\\n                timeToExpiry, // Number of seconds to expiry mul by 100\\r\\n                0,\\r\\n                volatility\\r\\n            )\\r\\n            .div(BlackScholes.DIVISOR);\\r\\n        uint256 minOptionPrice = lastPrice.mul(minOptionPricePercentage).div(1e10);\\r\\n\\r\\n        if (minOptionPrice > optionPrice) {\\r\\n            return minOptionPrice;\\r\\n        }\\r\\n\\r\\n        return optionPrice;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x9ce697bbbe1ae8c1a4d7c2f5a67c3e9772e3f8a38364b2675db7f7a1d73c33d6\",\"license\":\"UNLICENSED\"},\"contracts/interfaces/IOptionPricing.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IOptionPricing {\\n    function getOptionPrice(\\n        bool isPut,\\n        uint256 expiry,\\n        uint256 strike,\\n        uint256 lastPrice,\\n        uint256 baseIv\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2ce39291a92d1843653907520ab883c653e5e75e1d25a27e5bbf68e8aad767f4\",\"license\":\"UNLICENSED\"},\"contracts/libraries/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n    /*\\n     * 0.\\n     */\\n    bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n    /*\\n     * -0.\\n     */\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n    /*\\n     * +Infinity.\\n     */\\n    bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n    /*\\n     * -Infinity.\\n     */\\n    bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n    /*\\n     * Canonical NaN value.\\n     */\\n    bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n    /**\\n     * Convert signed 256-bit integer number into quadruple precision number.\\n     *\\n     * @param x signed 256-bit integer number\\n     * @return quadruple precision number\\n     */\\n    function fromInt(int256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint256(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16383 + msb) << 112);\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 256-bit integer number\\n     * rounding towards zero.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 256-bit integer number\\n     */\\n    function toInt(bytes16 x) internal pure returns (int256) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            require(exponent <= 16638); // Overflow\\n            if (exponent < 16383) return 0; // Underflow\\n\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16495) result >>= 16495 - exponent;\\n            else if (exponent > 16495) result <<= exponent - 16495;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n                return -int256(result); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int256(result);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert unsigned 256-bit integer number into quadruple precision number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return quadruple precision number\\n     */\\n    function fromUInt(uint256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                uint256 result = x;\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16383 + msb) << 112);\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into unsigned 256-bit integer number\\n     * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n     * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n     * without error, because they are rounded to zero.\\n     *\\n     * @param x quadruple precision number\\n     * @return unsigned 256-bit integer number\\n     */\\n    function toUInt(bytes16 x) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            if (exponent < 16383) return 0; // Underflow\\n\\n            require(uint128(x) < 0x80000000000000000000000000000000); // Negative\\n\\n            require(exponent <= 16638); // Overflow\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16495) result >>= 16495 - exponent;\\n            else if (exponent > 16495) result <<= exponent - 16495;\\n\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 128.128 bit fixed point number into quadruple precision\\n     * number.\\n     *\\n     * @param x signed 128.128 bit fixed point number\\n     * @return quadruple precision number\\n     */\\n    function from128x128(int256 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint256(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16255 + msb) << 112);\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 128.128 bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 128.128 bit fixed point number\\n     */\\n    function to128x128(bytes16 x) internal pure returns (int256) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            require(exponent <= 16510); // Overflow\\n            if (exponent < 16255) return 0; // Underflow\\n\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16367) result >>= 16367 - exponent;\\n            else if (exponent > 16367) result <<= exponent - 16367;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n                return -int256(result); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int256(result);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 64.64 bit fixed point number into quadruple precision\\n     * number.\\n     *\\n     * @param x signed 64.64 bit fixed point number\\n     * @return quadruple precision number\\n     */\\n    function from64x64(int128 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (x == 0) return bytes16(0);\\n            else {\\n                // We rely on overflow behavior here\\n                uint256 result = uint128(x > 0 ? x : -x);\\n\\n                uint256 msb = mostSignificantBit(result);\\n                if (msb < 112) result <<= 112 - msb;\\n                else if (msb > 112) result >>= msb - 112;\\n\\n                result = (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | ((16319 + msb) << 112);\\n                if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n                return bytes16(uint128(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into signed 64.64 bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x quadruple precision number\\n     * @return signed 64.64 bit fixed point number\\n     */\\n    function to64x64(bytes16 x) internal pure returns (int128) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            require(exponent <= 16446); // Overflow\\n            if (exponent < 16319) return 0; // Underflow\\n\\n            uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | 0x10000000000000000000000000000;\\n\\n            if (exponent < 16431) result >>= 16431 - exponent;\\n            else if (exponent > 16431) result <<= exponent - 16431;\\n\\n            if (uint128(x) >= 0x80000000000000000000000000000000) {\\n                // Negative\\n                require(result <= 0x80000000000000000000000000000000);\\n                return -int128(int256(result)); // We rely on overflow behavior here\\n            } else {\\n                require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int128(int256(result));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Convert octuple precision number into quadruple precision number.\\n     *\\n     * @param x octuple precision number\\n     * @return quadruple precision number\\n     */\\n    function fromOctuple(bytes32 x) internal pure returns (bytes16) {\\n        unchecked {\\n            bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n            uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\\n            uint256 significand = uint256(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFFF) {\\n                if (significand > 0) return NaN;\\n                else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            }\\n\\n            if (exponent > 278526) return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else if (exponent < 245649) return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n            else if (exponent < 245761) {\\n                significand =\\n                    (significand | 0x100000000000000000000000000000000000000000000000000000000000) >>\\n                    (245885 - exponent);\\n                exponent = 0;\\n            } else {\\n                significand >>= 124;\\n                exponent -= 245760;\\n            }\\n\\n            uint128 result = uint128(significand | (exponent << 112));\\n            if (negative) result |= 0x80000000000000000000000000000000;\\n\\n            return bytes16(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into octuple precision number.\\n     *\\n     * @param x quadruple precision number\\n     * @return octuple precision number\\n     */\\n    function toOctuple(bytes16 x) internal pure returns (bytes32) {\\n        unchecked {\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n            uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFF)\\n                exponent = 0x7FFFF; // Infinity or NaN\\n            else if (exponent == 0) {\\n                if (result > 0) {\\n                    uint256 msb = mostSignificantBit(result);\\n                    result = (result << (236 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    exponent = 245649 + msb;\\n                }\\n            } else {\\n                result <<= 124;\\n                exponent += 245760;\\n            }\\n\\n            result |= exponent << 236;\\n            if (uint128(x) >= 0x80000000000000000000000000000000)\\n                result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n            return bytes32(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert double precision number into quadruple precision number.\\n     *\\n     * @param x double precision number\\n     * @return quadruple precision number\\n     */\\n    function fromDouble(bytes8 x) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 exponent = (uint64(x) >> 52) & 0x7FF;\\n\\n            uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FF)\\n                exponent = 0x7FFF; // Infinity or NaN\\n            else if (exponent == 0) {\\n                if (result > 0) {\\n                    uint256 msb = mostSignificantBit(result);\\n                    result = (result << (112 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    exponent = 15309 + msb;\\n                }\\n            } else {\\n                result <<= 60;\\n                exponent += 15360;\\n            }\\n\\n            result |= exponent << 112;\\n            if (x & 0x8000000000000000 > 0) result |= 0x80000000000000000000000000000000;\\n\\n            return bytes16(uint128(result));\\n        }\\n    }\\n\\n    /**\\n     * Convert quadruple precision number into double precision number.\\n     *\\n     * @param x quadruple precision number\\n     * @return double precision number\\n     */\\n    function toDouble(bytes16 x) internal pure returns (bytes8) {\\n        unchecked {\\n            bool negative = uint128(x) >= 0x80000000000000000000000000000000;\\n\\n            uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (exponent == 0x7FFF) {\\n                if (significand > 0) return 0x7FF8000000000000;\\n                // NaN\\n                else\\n                    return\\n                        negative\\n                            ? bytes8(0xFFF0000000000000) // -Infinity\\n                            : bytes8(0x7FF0000000000000); // Infinity\\n            }\\n\\n            if (exponent > 17406)\\n                return\\n                    negative\\n                        ? bytes8(0xFFF0000000000000) // -Infinity\\n                        : bytes8(0x7FF0000000000000);\\n            // Infinity\\n            else if (exponent < 15309)\\n                return\\n                    negative\\n                        ? bytes8(0x8000000000000000) // -0\\n                        : bytes8(0x0000000000000000);\\n            // 0\\n            else if (exponent < 15361) {\\n                significand = (significand | 0x10000000000000000000000000000) >> (15421 - exponent);\\n                exponent = 0;\\n            } else {\\n                significand >>= 60;\\n                exponent -= 15360;\\n            }\\n\\n            uint64 result = uint64(significand | (exponent << 52));\\n            if (negative) result |= 0x8000000000000000;\\n\\n            return bytes8(result);\\n        }\\n    }\\n\\n    /**\\n     * Test whether given quadruple precision number is NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @return true if x is NaN, false otherwise\\n     */\\n    function isNaN(bytes16 x) internal pure returns (bool) {\\n        unchecked {\\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF > 0x7FFF0000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Test whether given quadruple precision number is positive or negative\\n     * infinity.\\n     *\\n     * @param x quadruple precision number\\n     * @return true if x is positive or negative infinity, false otherwise\\n     */\\n    function isInfinity(bytes16 x) internal pure returns (bool) {\\n        unchecked {\\n            return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0x7FFF0000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n     * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @return sign of x\\n     */\\n    function sign(bytes16 x) internal pure returns (int8) {\\n        unchecked {\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            if (absoluteX == 0) return 0;\\n            else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\\n            else return 1;\\n        }\\n    }\\n\\n    /**\\n     * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n     * arguments are infinities of the same sign.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return sign (x - y)\\n     */\\n    function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\\n        unchecked {\\n            uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n            // Not infinities of the same sign\\n            require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n            if (x == y) return 0;\\n            else {\\n                bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\\n                bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\\n\\n                if (negativeX) {\\n                    if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\\n                    else return -1;\\n                } else {\\n                    if (negativeY) return 1;\\n                    else return absoluteX > absoluteY ? int8(1) : -1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n     * anything.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return true if x equals to y, false otherwise\\n     */\\n    function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\\n        unchecked {\\n            if (x == y) {\\n                return uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF < 0x7FFF0000000000000000000000000000;\\n            } else return false;\\n        }\\n    }\\n\\n    /**\\n     * Calculate x + y.  Special values behave in the following way:\\n     *\\n     * NaN + x = NaN for any x.\\n     * Infinity + x = Infinity for any finite x.\\n     * -Infinity + x = -Infinity for any finite x.\\n     * Infinity + Infinity = Infinity.\\n     * -Infinity + -Infinity = -Infinity.\\n     * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) {\\n                    if (x == y) return x;\\n                    else return NaN;\\n                } else return x;\\n            } else if (yExponent == 0x7FFF) return y;\\n            else {\\n                bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n                else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n                else {\\n                    int256 delta = int256(xExponent) - int256(yExponent);\\n\\n                    if (xSign == ySign) {\\n                        if (delta > 112) return x;\\n                        else if (delta > 0) ySignifier >>= uint256(delta);\\n                        else if (delta < -112) return y;\\n                        else if (delta < 0) {\\n                            xSignifier >>= uint256(-delta);\\n                            xExponent = yExponent;\\n                        }\\n\\n                        xSignifier += ySignifier;\\n\\n                        if (xSignifier >= 0x20000000000000000000000000000) {\\n                            xSignifier >>= 1;\\n                            xExponent += 1;\\n                        }\\n\\n                        if (xExponent == 0x7FFF) return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n                        else {\\n                            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n                            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                            return\\n                                bytes16(\\n                                    uint128(\\n                                        (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                                            (xExponent << 112) |\\n                                            xSignifier\\n                                    )\\n                                );\\n                        }\\n                    } else {\\n                        if (delta > 0) {\\n                            xSignifier <<= 1;\\n                            xExponent -= 1;\\n                        } else if (delta < 0) {\\n                            ySignifier <<= 1;\\n                            xExponent = yExponent - 1;\\n                        }\\n\\n                        if (delta > 112) ySignifier = 1;\\n                        else if (delta > 1) ySignifier = ((ySignifier - 1) >> uint256(delta - 1)) + 1;\\n                        else if (delta < -112) xSignifier = 1;\\n                        else if (delta < -1) xSignifier = ((xSignifier - 1) >> uint256(-delta - 1)) + 1;\\n\\n                        if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n                        else {\\n                            xSignifier = ySignifier - xSignifier;\\n                            xSign = ySign;\\n                        }\\n\\n                        if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n                        uint256 msb = mostSignificantBit(xSignifier);\\n\\n                        if (msb == 113) {\\n                            xSignifier = (xSignifier >> 1) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                            xExponent += 1;\\n                        } else if (msb < 112) {\\n                            uint256 shift = 112 - msb;\\n                            if (xExponent > shift) {\\n                                xSignifier = (xSignifier << shift) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                                xExponent -= shift;\\n                            } else {\\n                                xSignifier <<= xExponent - 1;\\n                                xExponent = 0;\\n                            }\\n                        } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                        if (xExponent == 0x7FFF) return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n                        else\\n                            return\\n                                bytes16(\\n                                    uint128(\\n                                        (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                                            (xExponent << 112) |\\n                                            xSignifier\\n                                    )\\n                                );\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x - y.  Special values behave in the following way:\\n     *\\n     * NaN - x = NaN for any x.\\n     * Infinity - x = Infinity for any finite x.\\n     * -Infinity - x = -Infinity for any finite x.\\n     * Infinity - -Infinity = Infinity.\\n     * -Infinity - Infinity = -Infinity.\\n     * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            return add(x, y ^ 0x80000000000000000000000000000000);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y.  Special values behave in the following way:\\n     *\\n     * NaN * x = NaN for any x.\\n     * Infinity * x = Infinity for any finite positive x.\\n     * Infinity * x = -Infinity for any finite negative x.\\n     * -Infinity * x = -Infinity for any finite positive x.\\n     * -Infinity * x = Infinity for any finite negative x.\\n     * Infinity * 0 = NaN.\\n     * -Infinity * 0 = NaN.\\n     * Infinity * Infinity = Infinity.\\n     * Infinity * -Infinity = -Infinity.\\n     * -Infinity * Infinity = -Infinity.\\n     * -Infinity * -Infinity = Infinity.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) {\\n                    if (x == y) return x ^ (y & 0x80000000000000000000000000000000);\\n                    else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n                    else return NaN;\\n                } else {\\n                    if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                    else return x ^ (y & 0x80000000000000000000000000000000);\\n                }\\n            } else if (yExponent == 0x7FFF) {\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                else return y ^ (x & 0x80000000000000000000000000000000);\\n            } else {\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                xSignifier *= ySignifier;\\n                if (xSignifier == 0)\\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n                xExponent += yExponent;\\n\\n                uint256 msb = xSignifier >= 0x200000000000000000000000000000000000000000000000000000000\\n                    ? 225\\n                    : xSignifier >= 0x100000000000000000000000000000000000000000000000000000000\\n                    ? 224\\n                    : mostSignificantBit(xSignifier);\\n\\n                if (xExponent + msb < 16496) {\\n                    // Underflow\\n                    xExponent = 0;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb < 16608) {\\n                    // Subnormal\\n                    if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\\n                    else if (xExponent > 16496) xSignifier <<= xExponent - 16496;\\n                    xExponent = 0;\\n                } else if (xExponent + msb > 49373) {\\n                    xExponent = 0x7FFF;\\n                    xSignifier = 0;\\n                } else {\\n                    if (msb > 112) xSignifier >>= msb - 112;\\n                    else if (msb < 112) xSignifier <<= 112 - msb;\\n\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                    xExponent = xExponent + msb - 16607;\\n                }\\n\\n                return\\n                    bytes16(\\n                        uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)\\n                    );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y.  Special values behave in the following way:\\n     *\\n     * NaN / x = NaN for any x.\\n     * x / NaN = NaN for any x.\\n     * Infinity / x = Infinity for any finite non-negative x.\\n     * Infinity / x = -Infinity for any finite negative x including -0.\\n     * -Infinity / x = -Infinity for any finite non-negative x.\\n     * -Infinity / x = Infinity for any finite negative x including -0.\\n     * x / Infinity = 0 for any finite non-negative x.\\n     * x / -Infinity = -0 for any finite non-negative x.\\n     * x / Infinity = -0 for any finite non-negative x including -0.\\n     * x / -Infinity = 0 for any finite non-negative x including -0.\\n     *\\n     * Infinity / Infinity = NaN.\\n     * Infinity / -Infinity = -NaN.\\n     * -Infinity / Infinity = -NaN.\\n     * -Infinity / -Infinity = NaN.\\n     *\\n     * Division by zero behaves in the following way:\\n     *\\n     * x / 0 = Infinity for any finite positive x.\\n     * x / -0 = -Infinity for any finite positive x.\\n     * x / 0 = -Infinity for any finite negative x.\\n     * x / -0 = Infinity for any finite negative x.\\n     * 0 / 0 = NaN.\\n     * 0 / -0 = NaN.\\n     * -0 / 0 = NaN.\\n     * -0 / -0 = NaN.\\n     *\\n     * @param x quadruple precision number\\n     * @param y quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n        unchecked {\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n            if (xExponent == 0x7FFF) {\\n                if (yExponent == 0x7FFF) return NaN;\\n                else return x ^ (y & 0x80000000000000000000000000000000);\\n            } else if (yExponent == 0x7FFF) {\\n                if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n                else return POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000);\\n            } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n                if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n                else return POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000);\\n            } else {\\n                uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (yExponent == 0) yExponent = 1;\\n                else ySignifier |= 0x10000000000000000000000000000;\\n\\n                uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xExponent == 0) {\\n                    if (xSignifier != 0) {\\n                        uint256 shift = 226 - mostSignificantBit(xSignifier);\\n\\n                        xSignifier <<= shift;\\n\\n                        xExponent = 1;\\n                        yExponent += shift - 114;\\n                    }\\n                } else {\\n                    xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n                }\\n\\n                xSignifier = xSignifier / ySignifier;\\n                if (xSignifier == 0)\\n                    return (x ^ y) & 0x80000000000000000000000000000000 > 0 ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n                assert(xSignifier >= 0x1000000000000000000000000000);\\n\\n                uint256 msb = xSignifier >= 0x80000000000000000000000000000\\n                    ? mostSignificantBit(xSignifier)\\n                    : xSignifier >= 0x40000000000000000000000000000\\n                    ? 114\\n                    : xSignifier >= 0x20000000000000000000000000000\\n                    ? 113\\n                    : 112;\\n\\n                if (xExponent + msb > yExponent + 16497) {\\n                    // Overflow\\n                    xExponent = 0x7FFF;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb + 16380 < yExponent) {\\n                    // Underflow\\n                    xExponent = 0;\\n                    xSignifier = 0;\\n                } else if (xExponent + msb + 16268 < yExponent) {\\n                    // Subnormal\\n                    if (xExponent + 16380 > yExponent) xSignifier <<= xExponent + 16380 - yExponent;\\n                    else if (xExponent + 16380 < yExponent) xSignifier >>= yExponent - xExponent - 16380;\\n\\n                    xExponent = 0;\\n                } else {\\n                    // Normal\\n                    if (msb > 112) xSignifier >>= msb - 112;\\n\\n                    xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n                    xExponent = xExponent + msb + 16269 - yExponent;\\n                }\\n\\n                return\\n                    bytes16(\\n                        uint128(uint128((x ^ y) & 0x80000000000000000000000000000000) | (xExponent << 112) | xSignifier)\\n                    );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate -x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function neg(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return x ^ 0x80000000000000000000000000000000;\\n        }\\n    }\\n\\n    /**\\n     * Calculate |x|.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function abs(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        }\\n    }\\n\\n    /**\\n     * Calculate square root of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function sqrt(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n            else {\\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n                if (xExponent == 0x7FFF) return x;\\n                else {\\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    if (xExponent == 0) xExponent = 1;\\n                    else xSignifier |= 0x10000000000000000000000000000;\\n\\n                    if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n                    bool oddExponent = xExponent & 0x1 == 0;\\n                    xExponent = (xExponent + 16383) >> 1;\\n\\n                    if (oddExponent) {\\n                        if (xSignifier >= 0x10000000000000000000000000000) xSignifier <<= 113;\\n                        else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            uint256 shift = (226 - msb) & 0xFE;\\n                            xSignifier <<= shift;\\n                            xExponent -= (shift - 112) >> 1;\\n                        }\\n                    } else {\\n                        if (xSignifier >= 0x10000000000000000000000000000) xSignifier <<= 112;\\n                        else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            uint256 shift = (225 - msb) & 0xFE;\\n                            xSignifier <<= shift;\\n                            xExponent -= (shift - 112) >> 1;\\n                        }\\n                    }\\n\\n                    uint256 r = 0x10000000000000000000000000000;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1;\\n                    r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n                    uint256 r1 = xSignifier / r;\\n                    if (r1 < r) r = r1;\\n\\n                    return bytes16(uint128((xExponent << 112) | (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function log_2(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n            else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO;\\n            else {\\n                uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n                if (xExponent == 0x7FFF) return x;\\n                else {\\n                    uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    if (xExponent == 0) xExponent = 1;\\n                    else xSignifier |= 0x10000000000000000000000000000;\\n\\n                    if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n                    bool resultNegative;\\n                    uint256 resultExponent = 16495;\\n                    uint256 resultSignifier;\\n\\n                    if (xExponent >= 0x3FFF) {\\n                        resultNegative = false;\\n                        resultSignifier = xExponent - 0x3FFF;\\n                        xSignifier <<= 15;\\n                    } else {\\n                        resultNegative = true;\\n                        if (xSignifier >= 0x10000000000000000000000000000) {\\n                            resultSignifier = 0x3FFE - xExponent;\\n                            xSignifier <<= 15;\\n                        } else {\\n                            uint256 msb = mostSignificantBit(xSignifier);\\n                            resultSignifier = 16493 - msb;\\n                            xSignifier <<= 127 - msb;\\n                        }\\n                    }\\n\\n                    if (xSignifier == 0x80000000000000000000000000000000) {\\n                        if (resultNegative) resultSignifier += 1;\\n                        uint256 shift = 112 - mostSignificantBit(resultSignifier);\\n                        resultSignifier <<= shift;\\n                        resultExponent -= shift;\\n                    } else {\\n                        uint256 bb = resultNegative ? 1 : 0;\\n                        while (resultSignifier < 0x10000000000000000000000000000) {\\n                            resultSignifier <<= 1;\\n                            resultExponent -= 1;\\n\\n                            xSignifier *= xSignifier;\\n                            uint256 b = xSignifier >> 255;\\n                            resultSignifier += b ^ bb;\\n                            xSignifier >>= 127 + b;\\n                        }\\n                    }\\n\\n                    return\\n                        bytes16(\\n                            uint128(\\n                                (resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n                                    (resultExponent << 112) |\\n                                    (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                            )\\n                        );\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function ln(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n        }\\n    }\\n\\n    /**\\n     * Calculate 2^x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function pow_2(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\\n            uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n            uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n            else if (xExponent > 16397) return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n            else if (xExponent < 16255) return 0x3FFF0000000000000000000000000000;\\n            else {\\n                if (xExponent == 0) xExponent = 1;\\n                else xSignifier |= 0x10000000000000000000000000000;\\n\\n                if (xExponent > 16367) xSignifier <<= xExponent - 16367;\\n                else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\\n\\n                if (xNegative && xSignifier > 0x406E00000000000000000000000000000000) return POSITIVE_ZERO;\\n\\n                if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return POSITIVE_INFINITY;\\n\\n                uint256 resultExponent = xSignifier >> 128;\\n                xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                if (xNegative && xSignifier != 0) {\\n                    xSignifier = ~xSignifier;\\n                    resultExponent += 1;\\n                }\\n\\n                uint256 resultSignifier = 0x80000000000000000000000000000000;\\n                if (xSignifier & 0x80000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\n                if (xSignifier & 0x40000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\\n                if (xSignifier & 0x20000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\\n                if (xSignifier & 0x10000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\\n                if (xSignifier & 0x8000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\\n                if (xSignifier & 0x4000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\\n                if (xSignifier & 0x2000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\\n                if (xSignifier & 0x1000000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\\n                if (xSignifier & 0x800000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\\n                if (xSignifier & 0x400000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\\n                if (xSignifier & 0x200000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\\n                if (xSignifier & 0x100000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\\n                if (xSignifier & 0x80000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\\n                if (xSignifier & 0x40000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\\n                if (xSignifier & 0x20000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000162E525EE054754457D5995292026) >> 128;\\n                if (xSignifier & 0x10000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\\n                if (xSignifier & 0x8000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\\n                if (xSignifier & 0x4000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\\n                if (xSignifier & 0x2000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\n                if (xSignifier & 0x1000000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\n                if (xSignifier & 0x800000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\\n                if (xSignifier & 0x400000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\\n                if (xSignifier & 0x200000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\\n                if (xSignifier & 0x100000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\\n                if (xSignifier & 0x80000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\\n                if (xSignifier & 0x40000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\\n                if (xSignifier & 0x20000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\\n                if (xSignifier & 0x10000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\\n                if (xSignifier & 0x8000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\\n                if (xSignifier & 0x4000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\\n                if (xSignifier & 0x2000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\\n                if (xSignifier & 0x1000000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\n                if (xSignifier & 0x800000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\\n                if (xSignifier & 0x400000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\\n                if (xSignifier & 0x200000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\n                if (xSignifier & 0x100000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\\n                if (xSignifier & 0x80000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\\n                if (xSignifier & 0x40000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\\n                if (xSignifier & 0x20000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\n                if (xSignifier & 0x10000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\\n                if (xSignifier & 0x8000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\\n                if (xSignifier & 0x4000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >> 128;\\n                if (xSignifier & 0x2000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >> 128;\\n                if (xSignifier & 0x1000000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >> 128;\\n                if (xSignifier & 0x800000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\\n                if (xSignifier & 0x400000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\\n                if (xSignifier & 0x200000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000162E42FEFA39FE95583C2) >> 128;\\n                if (xSignifier & 0x100000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\\n                if (xSignifier & 0x80000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\\n                if (xSignifier & 0x40000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000002C5C85FDF473E242EA38) >> 128;\\n                if (xSignifier & 0x20000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\n                if (xSignifier & 0x10000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\n                if (xSignifier & 0x8000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\n                if (xSignifier & 0x4000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\n                if (xSignifier & 0x2000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000162E42FEFA39EF44D91) >> 128;\\n                if (xSignifier & 0x1000000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000B17217F7D1CF79E949) >> 128;\\n                if (xSignifier & 0x800000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\\n                if (xSignifier & 0x400000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\n                if (xSignifier & 0x200000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000162E42FEFA39EF366F) >> 128;\\n                if (xSignifier & 0x100000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\n                if (xSignifier & 0x80000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\\n                if (xSignifier & 0x40000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\\n                if (xSignifier & 0x20000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000162E42FEFA39EF358) >> 128;\\n                if (xSignifier & 0x10000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000B17217F7D1CF79AB) >> 128;\\n                if (xSignifier & 0x8000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >> 128;\\n                if (xSignifier & 0x4000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >> 128;\\n                if (xSignifier & 0x2000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >> 128;\\n                if (xSignifier & 0x1000000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000B17217F7D1CF799) >> 128;\\n                if (xSignifier & 0x800000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000058B90BFBE8E7BCC) >> 128;\\n                if (xSignifier & 0x400000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000002C5C85FDF473DE5) >> 128;\\n                if (xSignifier & 0x200000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000162E42FEFA39EF2) >> 128;\\n                if (xSignifier & 0x100000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000B17217F7D1CF78) >> 128;\\n                if (xSignifier & 0x80000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000058B90BFBE8E7BB) >> 128;\\n                if (xSignifier & 0x40000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000002C5C85FDF473DD) >> 128;\\n                if (xSignifier & 0x20000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000162E42FEFA39EE) >> 128;\\n                if (xSignifier & 0x10000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000B17217F7D1CF6) >> 128;\\n                if (xSignifier & 0x8000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000058B90BFBE8E7A) >> 128;\\n                if (xSignifier & 0x4000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000002C5C85FDF473C) >> 128;\\n                if (xSignifier & 0x2000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000162E42FEFA39D) >> 128;\\n                if (xSignifier & 0x1000000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000B17217F7D1CE) >> 128;\\n                if (xSignifier & 0x800000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000058B90BFBE8E6) >> 128;\\n                if (xSignifier & 0x400000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000002C5C85FDF472) >> 128;\\n                if (xSignifier & 0x200000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000162E42FEFA38) >> 128;\\n                if (xSignifier & 0x100000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000B17217F7D1B) >> 128;\\n                if (xSignifier & 0x80000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000058B90BFBE8D) >> 128;\\n                if (xSignifier & 0x40000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000002C5C85FDF46) >> 128;\\n                if (xSignifier & 0x20000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000162E42FEFA2) >> 128;\\n                if (xSignifier & 0x10000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000B17217F7D0) >> 128;\\n                if (xSignifier & 0x8000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000058B90BFBE7) >> 128;\\n                if (xSignifier & 0x4000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000002C5C85FDF3) >> 128;\\n                if (xSignifier & 0x2000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000162E42FEF9) >> 128;\\n                if (xSignifier & 0x1000000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000B17217F7C) >> 128;\\n                if (xSignifier & 0x800000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000058B90BFBD) >> 128;\\n                if (xSignifier & 0x400000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000002C5C85FDE) >> 128;\\n                if (xSignifier & 0x200000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000162E42FEE) >> 128;\\n                if (xSignifier & 0x100000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000B17217F6) >> 128;\\n                if (xSignifier & 0x80000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000058B90BFA) >> 128;\\n                if (xSignifier & 0x40000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000002C5C85FC) >> 128;\\n                if (xSignifier & 0x20000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000162E42FD) >> 128;\\n                if (xSignifier & 0x10000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000B17217E) >> 128;\\n                if (xSignifier & 0x8000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000058B90BE) >> 128;\\n                if (xSignifier & 0x4000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000002C5C85E) >> 128;\\n                if (xSignifier & 0x2000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000162E42E) >> 128;\\n                if (xSignifier & 0x1000000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000B17216) >> 128;\\n                if (xSignifier & 0x800000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000058B90A) >> 128;\\n                if (xSignifier & 0x400000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000002C5C84) >> 128;\\n                if (xSignifier & 0x200000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000162E41) >> 128;\\n                if (xSignifier & 0x100000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000B1720) >> 128;\\n                if (xSignifier & 0x80000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000058B8F) >> 128;\\n                if (xSignifier & 0x40000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000002C5C7) >> 128;\\n                if (xSignifier & 0x20000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000162E3) >> 128;\\n                if (xSignifier & 0x10000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000B171) >> 128;\\n                if (xSignifier & 0x8000 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000058B8) >> 128;\\n                if (xSignifier & 0x4000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000002C5B) >> 128;\\n                if (xSignifier & 0x2000 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000162D) >> 128;\\n                if (xSignifier & 0x1000 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000B16) >> 128;\\n                if (xSignifier & 0x800 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000058A) >> 128;\\n                if (xSignifier & 0x400 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000002C4) >> 128;\\n                if (xSignifier & 0x200 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000161) >> 128;\\n                if (xSignifier & 0x100 > 0)\\n                    resultSignifier = (resultSignifier * 0x1000000000000000000000000000000B0) >> 128;\\n                if (xSignifier & 0x80 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000057) >> 128;\\n                if (xSignifier & 0x40 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000002B) >> 128;\\n                if (xSignifier & 0x20 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000015) >> 128;\\n                if (xSignifier & 0x10 > 0)\\n                    resultSignifier = (resultSignifier * 0x10000000000000000000000000000000A) >> 128;\\n                if (xSignifier & 0x8 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000004) >> 128;\\n                if (xSignifier & 0x4 > 0)\\n                    resultSignifier = (resultSignifier * 0x100000000000000000000000000000001) >> 128;\\n\\n                if (!xNegative) {\\n                    resultSignifier = (resultSignifier >> 15) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    resultExponent += 0x3FFF;\\n                } else if (resultExponent <= 0x3FFE) {\\n                    resultSignifier = (resultSignifier >> 15) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                    resultExponent = 0x3FFF - resultExponent;\\n                } else {\\n                    resultSignifier = resultSignifier >> (resultExponent - 16367);\\n                    resultExponent = 0;\\n                }\\n\\n                return bytes16(uint128((resultExponent << 112) | resultSignifier));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate e^x.\\n     *\\n     * @param x quadruple precision number\\n     * @return quadruple precision number\\n     */\\n    function exp(bytes16 x) internal pure returns (bytes16) {\\n        unchecked {\\n            return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n        }\\n    }\\n\\n    /**\\n     * Get index of the most significant non-zero bit in binary representation of\\n     * x.  Reverts if x is zero.\\n     *\\n     * @return index of the most significant non-zero bit in binary representation\\n     *         of x\\n     */\\n    function mostSignificantBit(uint256 x) private pure returns (uint256) {\\n        unchecked {\\n            require(x > 0);\\n\\n            uint256 result = 0;\\n\\n            if (x >= 0x100000000000000000000000000000000) {\\n                x >>= 128;\\n                result += 128;\\n            }\\n            if (x >= 0x10000000000000000) {\\n                x >>= 64;\\n                result += 64;\\n            }\\n            if (x >= 0x100000000) {\\n                x >>= 32;\\n                result += 32;\\n            }\\n            if (x >= 0x10000) {\\n                x >>= 16;\\n                result += 16;\\n            }\\n            if (x >= 0x100) {\\n                x >>= 8;\\n                result += 8;\\n            }\\n            if (x >= 0x10) {\\n                x >>= 4;\\n                result += 4;\\n            }\\n            if (x >= 0x4) {\\n                x >>= 2;\\n                result += 2;\\n            }\\n            if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n            return result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5b668ad915207141aa1686bd5accd55b8f031a1a68878dd39d2840a0a94918aa\",\"license\":\"BSD-4-Clause\"},\"contracts/libraries/BlackScholes.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// Libraries\\r\\nimport { ABDKMathQuad } from \\\"./ABDKMathQuad.sol\\\";\\r\\n\\r\\n/// @title Black-Scholes option pricing formula and supporting statistical functions\\r\\n/// @author Dopex\\r\\n/// @notice This library implements the Black-Scholes model to price options.\\r\\n/// See - https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model\\r\\n/// @dev Implements the following implementation - https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html\\r\\n/// Uses the ABDKMathQuad(https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md)\\r\\n/// library to make precise calculations. It uses a DIVISOR (1e16) for maintaining precision in constants.\\r\\nlibrary BlackScholes {\\r\\n    uint8 internal constant OPTION_TYPE_CALL = 0;\\r\\n    uint8 internal constant OPTION_TYPE_PUT = 1;\\r\\n\\r\\n    uint256 internal constant DIVISOR = 10 ** 16;\\r\\n\\r\\n    /**\\r\\n     * @notice The function that uses the Black-Scholes equation to calculate the option price\\r\\n     * See http://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model#Black-Scholes_formula\\r\\n     * NOTE: The different parts of the equation are broken down to separate functions as using\\r\\n     * ABDKMathQuad makes small equations verbose.\\r\\n     * @param optionType Type of option - 0 = call, 1 = put\\r\\n     * @param price Stock price\\r\\n     * @param strike Strike price\\r\\n     * @param timeToExpiry Time to expiry in days\\r\\n     * @param riskFreeRate Risk-free rate\\r\\n     * @param volatility Volatility on the asset\\r\\n     * @return Option price based on the Black-Scholes model\\r\\n     */\\r\\n    function calculate(\\r\\n        uint8 optionType,\\r\\n        uint256 price,\\r\\n        uint256 strike,\\r\\n        uint256 timeToExpiry,\\r\\n        uint256 riskFreeRate,\\r\\n        uint256 volatility\\r\\n    ) internal view returns (uint256) {\\r\\n        bytes16 S = ABDKMathQuad.fromUInt(price);\\r\\n        bytes16 X = ABDKMathQuad.fromUInt(strike);\\r\\n        bytes16 T = ABDKMathQuad.div(\\r\\n            ABDKMathQuad.fromUInt(timeToExpiry),\\r\\n            ABDKMathQuad.fromUInt(100) // 365 * 10 ^ 2\\r\\n        );\\r\\n        bytes16 r = ABDKMathQuad.div(ABDKMathQuad.fromUInt(riskFreeRate), ABDKMathQuad.fromUInt(10000));\\r\\n        bytes16 v = ABDKMathQuad.div(ABDKMathQuad.fromUInt(volatility), ABDKMathQuad.fromUInt(100));\\r\\n        bytes16 d1 = ABDKMathQuad.div(\\r\\n            ABDKMathQuad.add(\\r\\n                ABDKMathQuad.ln(ABDKMathQuad.div(S, X)),\\r\\n                ABDKMathQuad.mul(\\r\\n                    ABDKMathQuad.add(r, ABDKMathQuad.mul(v, ABDKMathQuad.div(v, ABDKMathQuad.fromUInt(2)))),\\r\\n                    T\\r\\n                )\\r\\n            ),\\r\\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\\r\\n        );\\r\\n        bytes16 d2 = ABDKMathQuad.sub(d1, ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T)));\\r\\n        if (optionType == OPTION_TYPE_CALL) {\\r\\n            return\\r\\n                ABDKMathQuad.toUInt(\\r\\n                    ABDKMathQuad.mul(_calculateCallTimeDecay(S, d1, X, r, T, d2), ABDKMathQuad.fromUInt(DIVISOR))\\r\\n                );\\r\\n        } else if (optionType == OPTION_TYPE_PUT) {\\r\\n            return\\r\\n                ABDKMathQuad.toUInt(\\r\\n                    ABDKMathQuad.mul(_calculatePutTimeDecay(X, r, T, d2, S, d1), ABDKMathQuad.fromUInt(DIVISOR))\\r\\n                );\\r\\n        } else return 0;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to caluclate the call time decay\\r\\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation\\r\\n    /// ( S * CND(d1)-X * Math.exp(-r * T) * CND(d2) );\\r\\n    function _calculateCallTimeDecay(\\r\\n        bytes16 S,\\r\\n        bytes16 d1,\\r\\n        bytes16 X,\\r\\n        bytes16 r,\\r\\n        bytes16 T,\\r\\n        bytes16 d2\\r\\n    ) internal pure returns (bytes16) {\\r\\n        return\\r\\n            ABDKMathQuad.sub(\\r\\n                ABDKMathQuad.mul(S, CND(d1)),\\r\\n                ABDKMathQuad.mul(\\r\\n                    ABDKMathQuad.mul(X, ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))),\\r\\n                    CND(d2)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev Function to caluclate the put time decay\\r\\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\\r\\n    /// ( X * Math.exp(-r * T) * CND(-d2) - S * CND(-d1) );\\r\\n    function _calculatePutTimeDecay(\\r\\n        bytes16 X,\\r\\n        bytes16 r,\\r\\n        bytes16 T,\\r\\n        bytes16 d2,\\r\\n        bytes16 S,\\r\\n        bytes16 d1\\r\\n    ) internal pure returns (bytes16) {\\r\\n        bytes16 price_part1 = ABDKMathQuad.mul(\\r\\n            ABDKMathQuad.mul(X, ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))),\\r\\n            CND(ABDKMathQuad.neg(d2))\\r\\n        );\\r\\n        bytes16 price_part2 = ABDKMathQuad.mul(S, CND(ABDKMathQuad.neg(d1)));\\r\\n        bytes16 price = ABDKMathQuad.sub(price_part1, price_part2);\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Normal cumulative distribution function.\\r\\n     * See http://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function\\r\\n     * From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\\r\\n     * \\\"k = 1 / (1 + .2316419 * x); return ( 1 - Math.exp(-x * x / 2)/ Math.sqrt(2*Math.PI) * k * (.31938153 + k * (-.356563782 + k * (1.781477937 + k * (-1.821255978 + k * 1.330274429)))) );\\\"\\r\\n     * NOTE: The different parts of the equation are broken down to separate functions as using\\r\\n     * ABDKMathQuad makes small equations verbose.\\r\\n     */\\r\\n    function CND(bytes16 x) internal pure returns (bytes16) {\\r\\n        if (ABDKMathQuad.toInt(x) < 0) {\\r\\n            return (ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND(ABDKMathQuad.neg(x))));\\r\\n        } else {\\r\\n            bytes16 k = ABDKMathQuad.div(\\r\\n                ABDKMathQuad.fromUInt(1),\\r\\n                ABDKMathQuad.add(\\r\\n                    ABDKMathQuad.fromUInt(1),\\r\\n                    ABDKMathQuad.mul(\\r\\n                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(2316419000000000), ABDKMathQuad.fromUInt(DIVISOR)),\\r\\n                        x\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n            bytes16 CND_part2 = _getCNDPart2(k, x);\\r\\n            return ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND_part2);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getCNDPart2(bytes16 k, bytes16 x) internal pure returns (bytes16) {\\r\\n        return ABDKMathQuad.mul(_getCNDPart2_1(x), _getCNDPart2_2(k));\\r\\n    }\\r\\n\\r\\n    function _getCNDPart2_1(bytes16 x) internal pure returns (bytes16) {\\r\\n        return\\r\\n            ABDKMathQuad.div(\\r\\n                ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(x), ABDKMathQuad.div(x, ABDKMathQuad.fromUInt(2)))),\\r\\n                ABDKMathQuad.sqrt(\\r\\n                    ABDKMathQuad.mul(\\r\\n                        ABDKMathQuad.fromUInt(2),\\r\\n                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(31415926530000000), ABDKMathQuad.fromUInt(DIVISOR))\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function _getCNDPart2_2(bytes16 k) internal pure returns (bytes16) {\\r\\n        return\\r\\n            ABDKMathQuad.mul(\\r\\n                ABDKMathQuad.add(\\r\\n                    ABDKMathQuad.div(ABDKMathQuad.fromUInt(3193815300000000), ABDKMathQuad.fromUInt(DIVISOR)),\\r\\n                    ABDKMathQuad.mul(\\r\\n                        k,\\r\\n                        ABDKMathQuad.add(\\r\\n                            ABDKMathQuad.neg(\\r\\n                                ABDKMathQuad.div(\\r\\n                                    ABDKMathQuad.fromUInt(3565637820000000),\\r\\n                                    ABDKMathQuad.fromUInt(DIVISOR)\\r\\n                                )\\r\\n                            ),\\r\\n                            ABDKMathQuad.mul(\\r\\n                                k,\\r\\n                                ABDKMathQuad.add(\\r\\n                                    ABDKMathQuad.div(\\r\\n                                        ABDKMathQuad.fromUInt(17814779370000000),\\r\\n                                        ABDKMathQuad.fromUInt(DIVISOR)\\r\\n                                    ),\\r\\n                                    _getCNDPart2_2_1(k)\\r\\n                                )\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                k\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function _getCNDPart2_2_1(bytes16 k) internal pure returns (bytes16) {\\r\\n        return\\r\\n            ABDKMathQuad.mul(\\r\\n                k,\\r\\n                ABDKMathQuad.add(\\r\\n                    ABDKMathQuad.neg(\\r\\n                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(18212559780000000), ABDKMathQuad.fromUInt(DIVISOR))\\r\\n                    ),\\r\\n                    ABDKMathQuad.mul(\\r\\n                        k,\\r\\n                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(13302744290000000), ABDKMathQuad.fromUInt(DIVISOR))\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x8e49807565a38d4240485e97f1a754c5937f253d9160500046c96b9c1ead9259\",\"license\":\"UNLICENSED\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162002b6238038062002b6283398101604081905262000034916200009e565b6200003f336200004e565b600191909155600255620000c3565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008060408385031215620000b257600080fd5b505080516020909101519092909150565b612a8f80620000d36000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063715018a61161005b578063715018a6146100e85780638da5cb5b146100f2578063ad1ad5dc1461010d578063f2fde38b1461012057600080fd5b806305e927df1461008d57806325b2a93b146100a9578063326611f8146100b25780635b7b6d88146100d5575b600080fd5b61009660015481565b6040519081526020015b60405180910390f35b61009660025481565b6100c56100c0366004612940565b610133565b60405190151581526020016100a0565b6100966100e3366004612959565b610146565b6100f06101d4565b005b6000546040516001600160a01b0390911681526020016100a0565b6100c561011b366004612940565b6101e8565b6100f061012e3660046129a2565b6101fb565b600061013d610279565b50600255600190565b60008061015e606461015888426102d3565b906102e8565b90506000610190662386f26fc1000061018a8a61017c57600061017f565b60015b888a8760008b6102f4565b9061043a565b905060006101b26402540be40061018a600254896102e890919063ffffffff16565b9050818111156101c65792506101cb915050565b509150505b95945050505050565b6101dc610279565b6101e66000610446565b565b60006101f2610279565b50600190815590565b610203610279565b6001600160a01b03811661026d5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61027681610446565b50565b6000546001600160a01b031633146101e65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610264565b60006102df82846129e1565b90505b92915050565b60006102df82846129f4565b60008061030087610496565b9050600061030d87610496565b9050600061032c61031d88610496565b6103276064610496565b6104fd565b9050600061034761033c88610496565b610327612710610496565b9050600061035761031d88610496565b905060006103a961039c61037361036e89896104fd565b6107c4565b610391610396876103918861038c8a6103276002610496565b6107e7565b610a50565b886107e7565b6103278461038c88610e1a565b905060006103c3826103be8561038c89610e1a565b610ff3565b905060ff8e16610404576103f66103f16103e189858a898b88611005565b61038c662386f26fc10000610496565b61104a565b975050505050505050610430565b60001960ff8f1601610424576103f66103f16103e1888789868d896110ce565b60009750505050505050505b9695505050505050565b60006102df8284612a21565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000816000036104a857506000919050565b8160006104b48261112d565b905060708110156104cd578060700382901b91506104e0565b60708111156104e0576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908290036105425780617fff03610531575061ffff60ef1b91506102e29050565b505050600160ff1b811682186102e2565b80617fff03610585576dffffffffffffffffffffffffffff60801b841615610574575061ffff60ef1b91506102e29050565b505050808218600160ff1b166102e2565b600160801b600160ff1b0384166000036105d557600160801b600160ff1b0385166000036105bd575061ffff60ef1b91506102e29050565b505050808218600160ff1b16617fff60f01b176102e2565b6001600160701b03608085901c1660008290036105f557600191506105fc565b600160701b175b6001600160701b03608087901c16600084900361063f57801561063a5760006106248261112d565b6001955060e20393840160711901939190911b90505b610649565b600160701b1760721b5b81818161065857610658612a0b565b0490508060000361068857600160ff1b8787181661067757600061067d565b600160ff1b5b9450505050506102e2565b6001606c1b81101561069c5761069c612a43565b6000600160731b8210156106db57600160721b8210156106d057600160711b8210156106c95760706106d3565b60716106d3565b60725b60ff166106e4565b6106e48261112d565b90508361407101818601111561070257617fff945060009150610795565b83818601613ffc01101561071d576000945060009150610795565b83818601613f8c01101561076a578385613ffc011115610748578385613ffc010382901b9150610761565b8385613ffc01101561076157613ffc8585030382901c91505b60009450610795565b607081111561077d576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e2565b60006102e26107d2836111cb565b6f3ffe62e42fefa39ef35793c7673007e560801b5b6000617fff60f084811c8216919084901c8116908290036108865780617fff03610862576001600160801b03198085169086160361083057505050600160ff1b811682186102e2565b6001600160801b031985851816600160ff1b03610852575050508181176102e2565b5061ffff60ef1b91506102e29050565b600160801b600160ff1b038416600003610531575061ffff60ef1b91506102e29050565b80617fff036108c457600160801b600160ff1b0385166000036108b3575061ffff60ef1b91506102e29050565b505050600160ff1b821681186102e2565b6001600160701b03608086901c1660008390036108e457600192506108eb565b600160701b175b6001600160701b03608086901c16600083900361090b5760019250610912565b600160701b175b80820291508160000361093357600160ff1b8787181661067757600061067d565b928201926000600160e11b83101561096657600160e01b83101561095f5761095a8361112d565b610969565b60e0610969565b60e15b90506140708186011015610984576000945060009250610a21565b6140e081860110156109c7576140708510156109a957846140700383901c92506109be565b6140708511156109be57614070850383901b92505b60009450610a21565b61c0dd81860111156109e157617fff945060009250610a21565b60708111156109f8576070810383901c9250610a0b565b6070811015610a0b578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e2565b6000617fff60f084811c8216919084901c811690829003610a9c5780617fff03610a92576001600160801b0319808516908616036108525784925050506102e2565b84925050506102e2565b80617fff03610aaf5783925050506102e2565b6001607f1b608086901c90811015906001600160701b03166000849003610ad95760019350610ae0565b600160701b175b6001607f1b608087901c90811015906001600160701b03166000859003610b0a5760019450610b11565b600160701b175b82600003610b44576001600160801b03198816600160ff1b14610b345787610b37565b60005b96505050505050506102e2565b80600003610b67576001600160801b03198916600160ff1b14610b345788610b37565b84860382151585151503610c70576070811315610b8d57899750505050505050506102e2565b6000811315610b9f5790811c90610bce565b606f19811215610bb857889750505050505050506102e2565b6000811215610bce578060000384901c93508596505b92810192600160711b8410610be9576001968701969390931c925b86617fff03610c1a5784610c0257617fff60f01b610c0c565b6001600160f01b03195b9750505050505050506102e2565b600160701b841015610c2f5760009650610c3c565b6001600160701b03841693505b83607088901b86610c4e576000610c54565b6001607f1b5b6001600160801b0316171760801b9750505050505050506102e2565b6000811315610c8b57600184901b9350600187039650610ca2565b6000811215610ca257600182901b91506001860396505b6070811315610cb45760019150610d01565b6001811315610cd1576001810360018303901c6001019150610d01565b606f19811215610ce45760019350610d01565b600019811215610d01576001816000030360018503901c60010193505b818410610d12578184039350610d1b565b83820393508294505b83600003610d345750600096506102e295505050505050565b6000610d3f8561112d565b905080607103610d6457600185901c6001600160701b03169450600188019750610db3565b6070811015610da657607081900380891115610d93578086901b6001600160701b031695508089039850610da0565b600098600019019590951b945b50610db3565b6001600160701b03851694505b87617fff03610de55785610dcc57617fff60f01b610dd6565b6001600160f01b03195b985050505050505050506102e2565b84607089901b87610df7576000610dfd565b6001607f1b5b6001600160801b0316171760801b985050505050505050506102e2565b60006001607f1b608083901c1115610e38575061ffff60ef1b919050565b617fff60f083901c811690819003610e51575090919050565b6001600160701b03608084901c166000829003610e715760019150610e78565b600160701b175b80600003610e8a575060009392505050565b613fff8201600190811c9216158015610edc57600160701b8210610eb457607182901b9150610f17565b6000610ebf8361112d565b60e20360fe16606f19810160011c909403939290921b9150610f17565b600160701b8210610ef357607082901b9150610f17565b6000610efe8361112d565b60e10360fe16606f19810160011c909403939290921b91505b600160701b80830401600190811c90818481610f3557610f35612a0b565b048201901c90506001818481610f4d57610f4d612a0b565b048201901c90506001818481610f6557610f65612a0b565b048201901c90506001818481610f7d57610f7d612a0b565b048201901c90506001818481610f9557610f95612a0b565b048201901c90506001818481610fad57610fad612a0b565b048201901c90506000818481610fc557610fc5612a0b565b04905081811015610fd4578091505b816001600160701b0316607086901b1760801b95505050505050919050565b60006102df83600160ff1b8418610a50565b600061103f6110178861038c89611383565b6103be6110368861038c611031600160ff1b8b188a6107e7565b61141e565b61038c86611383565b979650505050505050565b6000617fff60f083901c16613fff8110156110685750600092915050565b6001607f1b608084901c1061107c57600080fd5b6140fe81111561108b57600080fd5b600160701b6001600160701b03608085901c161761406f8210156110b55761406f8290031c6110c7565b61406f8211156110c75761406e1982011b5b9392505050565b6000806110fa6110eb8961038c611031600160ff1b8c188b6107e7565b61038c600160ff1b8818611383565b905060006111118561038c600160ff1b8718611383565b9050600061111f8383610ff3565b9a9950505050505050505050565b600080821161113b57600080fd5b6000600160801b831061115057608092831c92015b600160401b831061116357604092831c92015b640100000000831061117757602092831c92015b62010000831061118957601092831c92015b610100831061119a57600892831c92015b601083106111aa57600492831c92015b600483106111ba57600292831c92015b600283106102e25760010192915050565b60006001607f1b608083901c11156111e9575061ffff60ef1b919050565b6001600160801b03198216613fff60f01b0361120757506000919050565b617fff60f083901c811690819003611220575090919050565b6001600160701b03608084901c1660008290036112405760019150611247565b600160701b175b8060000361126057506001600160f01b03199392505050565b600061406f81613fff85106112865750600f9290921b9160009150613ffe1984016112c5565b60019250600160701b84106112a85784613ffe039050600f84901b93506112c5565b60006112b38561112d565b607f8190039590951b9461406d039150505b836001607f1b036112fb5782156112da576001015b60006112e58261112d565b60700390508082901b9150808303925050611349565b60008361130957600061130c565b60015b60ff1690505b600160701b8210156113475793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190611312565b505b806001600160701b0316607083901b8461136457600061136a565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60008061138f83611445565b12156113b1576102e26113a26001610496565b6103be600160ff1b8518611383565b60006113f36113c06001610496565b6103276113cd6001610496565b6103916103966113e366083ac553a55e00610496565b610327662386f26fc10000610496565b9050600061140182856114ec565b90506114166114106001610496565b82610ff3565b949350505050565b60006102e2611440836f1fffb8aa3b295c17f0bbbe87fed0691d60811b6107e7565b611503565b6000617fff60f083901c166140fe81111561145f57600080fd5b613fff8110156114725750600092915050565b600160701b6001600160701b03608085901c161761406f82101561149c5761406f8290031c6114ae565b61406f8211156114ae5761406e1982011b5b6001607f1b608085901c106114d857600160ff1b8111156114ce57600080fd5b6000039392505050565b6001600160ff1b038111156110c757600080fd5b60006102df6114fa83612858565b61038c856128a0565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561153557508015155b15611549575061ffff60ef1b949350505050565b61400d82111561156e578261156357617fff60f01b6101cb565b600095945050505050565b613f7f8210156115875750613fff60f01b949350505050565b81600003611598576001915061159f565b600160701b175b613fef8211156115b557613fee1982011b6115c7565b613fef8210156115c757613fef8290031c5b8280156115d8575061203760811b81115b156115e857506000949350505050565b821580156116075750713fffffffffffffffffffffffffffffffffff81115b1561161b5750617fff60f01b949350505050565b6001600160801b0381169060801c83801561163557508115155b15611641579019906001015b6001607f1b828116156116655770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611688577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156116ab577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156116ce5770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156116f1577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561171457700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156117375770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561175a57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b83161561177d5770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b8316156117a0577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b8316156117c357700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b8316156117e6577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561180957700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b83161561182c5770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b83161561184f577001000162e525ee054754457d59952920260260801c5b600160701b8316156118725770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611895577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b8316156118b857700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156118db5770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156118fe57700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156119215770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611944577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561196757700100000162e430e5a18f6119e3c02282a50260801c5b600160681b83161561198a577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b8316156119ad57700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156119d05770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156119f3577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611a165770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611a39577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611a5c57700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611a7f5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611aa257700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611ac55770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611ae8577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611b0b57700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611b2e577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611b5157700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611b745770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611b97577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611bba5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611bdd577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611c0057700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611c235770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611c4657700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611c695770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611c8c577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611caf57700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611cd2577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611cfb57700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611d245770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611d4d577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611d765770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611d9f577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611dc857700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611df15770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611e1a57700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611e425770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611e6a577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611e9257700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611eba577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611ee257700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611f0a5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611f32577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611f555770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611f7c577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611fa357700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611fca5770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611ff157700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156120185770010000000000000000058b90bfbe8e7bcc0260801c5b67040000000000000083161561203f577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561206657700100000000000000000162e42fefa39ef20260801c5b67010000000000000083161561208d577001000000000000000000b17217f7d1cf780260801c5b66800000000000008316156120b357700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156120d95770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156120ff577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156121255770010000000000000000000b17217f7d1cf60260801c5b660800000000000083161561214b577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561217157700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156121975770010000000000000000000162e42fefa39d0260801c5b66010000000000008316156121bd57700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156121e25770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612207577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561222c57700100000000000000000000162e42fefa380260801c5b65100000000000831615612251577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561227657700100000000000000000000058b90bfbe8d0260801c5b6504000000000083161561229b5770010000000000000000000002c5c85fdf460260801c5b650200000000008316156122c0577001000000000000000000000162e42fefa20260801c5b650100000000008316156122e55770010000000000000000000000b17217f7d00260801c5b648000000000831615612309577001000000000000000000000058b90bfbe70260801c5b64400000000083161561232d57700100000000000000000000002c5c85fdf30260801c5b6420000000008316156123515770010000000000000000000000162e42fef90260801c5b64100000000083161561237557700100000000000000000000000b17217f7c0260801c5b6408000000008316156123995770010000000000000000000000058b90bfbd0260801c5b6404000000008316156123bd577001000000000000000000000002c5c85fde0260801c5b6402000000008316156123e157700100000000000000000000000162e42fee0260801c5b640100000000831615612405577001000000000000000000000000b17217f60260801c5b638000000083161561242857700100000000000000000000000058b90bfa0260801c5b634000000083161561244b5770010000000000000000000000002c5c85fc0260801c5b632000000083161561246e577001000000000000000000000000162e42fd0260801c5b63100000008316156124915770010000000000000000000000000b17217e0260801c5b63080000008316156124b4577001000000000000000000000000058b90be0260801c5b63040000008316156124d757700100000000000000000000000002c5c85e0260801c5b63020000008316156124fa5770010000000000000000000000000162e42e0260801c5b630100000083161561251d57700100000000000000000000000000b172160260801c5b6280000083161561253f5770010000000000000000000000000058b90a0260801c5b62400000831615612561577001000000000000000000000000002c5c840260801c5b6220000083161561258357700100000000000000000000000000162e410260801c5b621000008316156125a5577001000000000000000000000000000b17200260801c5b620800008316156125c757700100000000000000000000000000058b8f0260801c5b620400008316156125e95770010000000000000000000000000002c5c70260801c5b6202000083161561260b577001000000000000000000000000000162e30260801c5b6201000083161561262d5770010000000000000000000000000000b1710260801c5b61800083161561264e577001000000000000000000000000000058b80260801c5b61400083161561266f57700100000000000000000000000000002c5b0260801c5b6120008316156126905770010000000000000000000000000000162d0260801c5b6110008316156126b157700100000000000000000000000000000b160260801c5b6108008316156126d25770010000000000000000000000000000058a0260801c5b6104008316156126f3577001000000000000000000000000000002c40260801c5b610200831615612714577001000000000000000000000000000001610260801c5b610100831615612735577001000000000000000000000000000000b00260801c5b6080831615612755577001000000000000000000000000000000570260801c5b60408316156127755770010000000000000000000000000000002b0260801c5b6020831615612795577001000000000000000000000000000000150260801c5b60108316156127b55770010000000000000000000000000000000a0260801c5b60088316156127d5577001000000000000000000000000000000040260801c5b60048316156127f5577001000000000000000000000000000000010260801c5b8461281657600f81901c6001600160701b03169050613fff82019150612845565b613ffe821161283b57600f81901c6001600160701b0316905081613fff039150612845565b600091613fee19011c5b60709190911b1760801b95945050505050565b60006102e2612878611031600160ff1b851861038c866103276002610496565b61032761289b6128886002610496565b61038c6113e3666f9c9e651c4480610496565b610e1a565b60006102e26129046128bb6113e3660b58c2126f4900610496565b6103918561038c6128e16128d86113e3660caaedbfa8a700610496565b600160ff1b1890565b6103918961038c6128fb6113e3663f4a728c19ce80610496565b6103918d61290a565b836107e7565b60006102e28261038c6129296128d86113e36640b43a04233100610496565b6103918661038c6113e3662f42c683f17c80610496565b60006020828403121561295257600080fd5b5035919050565b600080600080600060a0868803121561297157600080fd5b8535801515811461298157600080fd5b97602087013597506040870135966060810135965060800135945092505050565b6000602082840312156129b457600080fd5b81356001600160a01b03811681146110c757600080fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156102e2576102e26129cb565b80820281158282048414176102e2576102e26129cb565b634e487b7160e01b600052601260045260246000fd5b600082612a3e57634e487b7160e01b600052601260045260246000fd5b500490565b634e487b7160e01b600052600160045260246000fdfea26469706673582212202f4b517d86ed4855d9fcb3b65f162675580e09a7d215fd8a0d933ae2557192a664736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063715018a61161005b578063715018a6146100e85780638da5cb5b146100f2578063ad1ad5dc1461010d578063f2fde38b1461012057600080fd5b806305e927df1461008d57806325b2a93b146100a9578063326611f8146100b25780635b7b6d88146100d5575b600080fd5b61009660015481565b6040519081526020015b60405180910390f35b61009660025481565b6100c56100c0366004612940565b610133565b60405190151581526020016100a0565b6100966100e3366004612959565b610146565b6100f06101d4565b005b6000546040516001600160a01b0390911681526020016100a0565b6100c561011b366004612940565b6101e8565b6100f061012e3660046129a2565b6101fb565b600061013d610279565b50600255600190565b60008061015e606461015888426102d3565b906102e8565b90506000610190662386f26fc1000061018a8a61017c57600061017f565b60015b888a8760008b6102f4565b9061043a565b905060006101b26402540be40061018a600254896102e890919063ffffffff16565b9050818111156101c65792506101cb915050565b509150505b95945050505050565b6101dc610279565b6101e66000610446565b565b60006101f2610279565b50600190815590565b610203610279565b6001600160a01b03811661026d5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b61027681610446565b50565b6000546001600160a01b031633146101e65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610264565b60006102df82846129e1565b90505b92915050565b60006102df82846129f4565b60008061030087610496565b9050600061030d87610496565b9050600061032c61031d88610496565b6103276064610496565b6104fd565b9050600061034761033c88610496565b610327612710610496565b9050600061035761031d88610496565b905060006103a961039c61037361036e89896104fd565b6107c4565b610391610396876103918861038c8a6103276002610496565b6107e7565b610a50565b886107e7565b6103278461038c88610e1a565b905060006103c3826103be8561038c89610e1a565b610ff3565b905060ff8e16610404576103f66103f16103e189858a898b88611005565b61038c662386f26fc10000610496565b61104a565b975050505050505050610430565b60001960ff8f1601610424576103f66103f16103e1888789868d896110ce565b60009750505050505050505b9695505050505050565b60006102df8284612a21565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000816000036104a857506000919050565b8160006104b48261112d565b905060708110156104cd578060700382901b91506104e0565b60708111156104e0576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908290036105425780617fff03610531575061ffff60ef1b91506102e29050565b505050600160ff1b811682186102e2565b80617fff03610585576dffffffffffffffffffffffffffff60801b841615610574575061ffff60ef1b91506102e29050565b505050808218600160ff1b166102e2565b600160801b600160ff1b0384166000036105d557600160801b600160ff1b0385166000036105bd575061ffff60ef1b91506102e29050565b505050808218600160ff1b16617fff60f01b176102e2565b6001600160701b03608085901c1660008290036105f557600191506105fc565b600160701b175b6001600160701b03608087901c16600084900361063f57801561063a5760006106248261112d565b6001955060e20393840160711901939190911b90505b610649565b600160701b1760721b5b81818161065857610658612a0b565b0490508060000361068857600160ff1b8787181661067757600061067d565b600160ff1b5b9450505050506102e2565b6001606c1b81101561069c5761069c612a43565b6000600160731b8210156106db57600160721b8210156106d057600160711b8210156106c95760706106d3565b60716106d3565b60725b60ff166106e4565b6106e48261112d565b90508361407101818601111561070257617fff945060009150610795565b83818601613ffc01101561071d576000945060009150610795565b83818601613f8c01101561076a578385613ffc011115610748578385613ffc010382901b9150610761565b8385613ffc01101561076157613ffc8585030382901c91505b60009450610795565b607081111561077d576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e2565b60006102e26107d2836111cb565b6f3ffe62e42fefa39ef35793c7673007e560801b5b6000617fff60f084811c8216919084901c8116908290036108865780617fff03610862576001600160801b03198085169086160361083057505050600160ff1b811682186102e2565b6001600160801b031985851816600160ff1b03610852575050508181176102e2565b5061ffff60ef1b91506102e29050565b600160801b600160ff1b038416600003610531575061ffff60ef1b91506102e29050565b80617fff036108c457600160801b600160ff1b0385166000036108b3575061ffff60ef1b91506102e29050565b505050600160ff1b821681186102e2565b6001600160701b03608086901c1660008390036108e457600192506108eb565b600160701b175b6001600160701b03608086901c16600083900361090b5760019250610912565b600160701b175b80820291508160000361093357600160ff1b8787181661067757600061067d565b928201926000600160e11b83101561096657600160e01b83101561095f5761095a8361112d565b610969565b60e0610969565b60e15b90506140708186011015610984576000945060009250610a21565b6140e081860110156109c7576140708510156109a957846140700383901c92506109be565b6140708511156109be57614070850383901b92505b60009450610a21565b61c0dd81860111156109e157617fff945060009250610a21565b60708111156109f8576070810383901c9250610a0b565b6070811015610a0b578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102e2565b6000617fff60f084811c8216919084901c811690829003610a9c5780617fff03610a92576001600160801b0319808516908616036108525784925050506102e2565b84925050506102e2565b80617fff03610aaf5783925050506102e2565b6001607f1b608086901c90811015906001600160701b03166000849003610ad95760019350610ae0565b600160701b175b6001607f1b608087901c90811015906001600160701b03166000859003610b0a5760019450610b11565b600160701b175b82600003610b44576001600160801b03198816600160ff1b14610b345787610b37565b60005b96505050505050506102e2565b80600003610b67576001600160801b03198916600160ff1b14610b345788610b37565b84860382151585151503610c70576070811315610b8d57899750505050505050506102e2565b6000811315610b9f5790811c90610bce565b606f19811215610bb857889750505050505050506102e2565b6000811215610bce578060000384901c93508596505b92810192600160711b8410610be9576001968701969390931c925b86617fff03610c1a5784610c0257617fff60f01b610c0c565b6001600160f01b03195b9750505050505050506102e2565b600160701b841015610c2f5760009650610c3c565b6001600160701b03841693505b83607088901b86610c4e576000610c54565b6001607f1b5b6001600160801b0316171760801b9750505050505050506102e2565b6000811315610c8b57600184901b9350600187039650610ca2565b6000811215610ca257600182901b91506001860396505b6070811315610cb45760019150610d01565b6001811315610cd1576001810360018303901c6001019150610d01565b606f19811215610ce45760019350610d01565b600019811215610d01576001816000030360018503901c60010193505b818410610d12578184039350610d1b565b83820393508294505b83600003610d345750600096506102e295505050505050565b6000610d3f8561112d565b905080607103610d6457600185901c6001600160701b03169450600188019750610db3565b6070811015610da657607081900380891115610d93578086901b6001600160701b031695508089039850610da0565b600098600019019590951b945b50610db3565b6001600160701b03851694505b87617fff03610de55785610dcc57617fff60f01b610dd6565b6001600160f01b03195b985050505050505050506102e2565b84607089901b87610df7576000610dfd565b6001607f1b5b6001600160801b0316171760801b985050505050505050506102e2565b60006001607f1b608083901c1115610e38575061ffff60ef1b919050565b617fff60f083901c811690819003610e51575090919050565b6001600160701b03608084901c166000829003610e715760019150610e78565b600160701b175b80600003610e8a575060009392505050565b613fff8201600190811c9216158015610edc57600160701b8210610eb457607182901b9150610f17565b6000610ebf8361112d565b60e20360fe16606f19810160011c909403939290921b9150610f17565b600160701b8210610ef357607082901b9150610f17565b6000610efe8361112d565b60e10360fe16606f19810160011c909403939290921b91505b600160701b80830401600190811c90818481610f3557610f35612a0b565b048201901c90506001818481610f4d57610f4d612a0b565b048201901c90506001818481610f6557610f65612a0b565b048201901c90506001818481610f7d57610f7d612a0b565b048201901c90506001818481610f9557610f95612a0b565b048201901c90506001818481610fad57610fad612a0b565b048201901c90506000818481610fc557610fc5612a0b565b04905081811015610fd4578091505b816001600160701b0316607086901b1760801b95505050505050919050565b60006102df83600160ff1b8418610a50565b600061103f6110178861038c89611383565b6103be6110368861038c611031600160ff1b8b188a6107e7565b61141e565b61038c86611383565b979650505050505050565b6000617fff60f083901c16613fff8110156110685750600092915050565b6001607f1b608084901c1061107c57600080fd5b6140fe81111561108b57600080fd5b600160701b6001600160701b03608085901c161761406f8210156110b55761406f8290031c6110c7565b61406f8211156110c75761406e1982011b5b9392505050565b6000806110fa6110eb8961038c611031600160ff1b8c188b6107e7565b61038c600160ff1b8818611383565b905060006111118561038c600160ff1b8718611383565b9050600061111f8383610ff3565b9a9950505050505050505050565b600080821161113b57600080fd5b6000600160801b831061115057608092831c92015b600160401b831061116357604092831c92015b640100000000831061117757602092831c92015b62010000831061118957601092831c92015b610100831061119a57600892831c92015b601083106111aa57600492831c92015b600483106111ba57600292831c92015b600283106102e25760010192915050565b60006001607f1b608083901c11156111e9575061ffff60ef1b919050565b6001600160801b03198216613fff60f01b0361120757506000919050565b617fff60f083901c811690819003611220575090919050565b6001600160701b03608084901c1660008290036112405760019150611247565b600160701b175b8060000361126057506001600160f01b03199392505050565b600061406f81613fff85106112865750600f9290921b9160009150613ffe1984016112c5565b60019250600160701b84106112a85784613ffe039050600f84901b93506112c5565b60006112b38561112d565b607f8190039590951b9461406d039150505b836001607f1b036112fb5782156112da576001015b60006112e58261112d565b60700390508082901b9150808303925050611349565b60008361130957600061130c565b60015b60ff1690505b600160701b8210156113475793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190611312565b505b806001600160701b0316607083901b8461136457600061136a565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60008061138f83611445565b12156113b1576102e26113a26001610496565b6103be600160ff1b8518611383565b60006113f36113c06001610496565b6103276113cd6001610496565b6103916103966113e366083ac553a55e00610496565b610327662386f26fc10000610496565b9050600061140182856114ec565b90506114166114106001610496565b82610ff3565b949350505050565b60006102e2611440836f1fffb8aa3b295c17f0bbbe87fed0691d60811b6107e7565b611503565b6000617fff60f083901c166140fe81111561145f57600080fd5b613fff8110156114725750600092915050565b600160701b6001600160701b03608085901c161761406f82101561149c5761406f8290031c6114ae565b61406f8211156114ae5761406e1982011b5b6001607f1b608085901c106114d857600160ff1b8111156114ce57600080fd5b6000039392505050565b6001600160ff1b038111156110c757600080fd5b60006102df6114fa83612858565b61038c856128a0565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561153557508015155b15611549575061ffff60ef1b949350505050565b61400d82111561156e578261156357617fff60f01b6101cb565b600095945050505050565b613f7f8210156115875750613fff60f01b949350505050565b81600003611598576001915061159f565b600160701b175b613fef8211156115b557613fee1982011b6115c7565b613fef8210156115c757613fef8290031c5b8280156115d8575061203760811b81115b156115e857506000949350505050565b821580156116075750713fffffffffffffffffffffffffffffffffff81115b1561161b5750617fff60f01b949350505050565b6001600160801b0381169060801c83801561163557508115155b15611641579019906001015b6001607f1b828116156116655770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611688577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156116ab577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156116ce5770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156116f1577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561171457700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156117375770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561175a57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b83161561177d5770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b8316156117a0577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b8316156117c357700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b8316156117e6577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561180957700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b83161561182c5770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b83161561184f577001000162e525ee054754457d59952920260260801c5b600160701b8316156118725770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611895577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b8316156118b857700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156118db5770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156118fe57700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156119215770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611944577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561196757700100000162e430e5a18f6119e3c02282a50260801c5b600160681b83161561198a577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b8316156119ad57700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156119d05770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156119f3577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611a165770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611a39577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611a5c57700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611a7f5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611aa257700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611ac55770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611ae8577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611b0b57700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611b2e577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611b5157700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611b745770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611b97577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611bba5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611bdd577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611c0057700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611c235770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611c4657700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611c695770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611c8c577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611caf57700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611cd2577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611cfb57700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611d245770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611d4d577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611d765770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611d9f577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611dc857700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611df15770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611e1a57700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611e425770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611e6a577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611e9257700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611eba577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611ee257700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611f0a5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611f32577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611f555770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611f7c577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611fa357700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611fca5770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611ff157700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156120185770010000000000000000058b90bfbe8e7bcc0260801c5b67040000000000000083161561203f577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561206657700100000000000000000162e42fefa39ef20260801c5b67010000000000000083161561208d577001000000000000000000b17217f7d1cf780260801c5b66800000000000008316156120b357700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156120d95770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156120ff577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156121255770010000000000000000000b17217f7d1cf60260801c5b660800000000000083161561214b577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561217157700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156121975770010000000000000000000162e42fefa39d0260801c5b66010000000000008316156121bd57700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156121e25770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612207577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561222c57700100000000000000000000162e42fefa380260801c5b65100000000000831615612251577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561227657700100000000000000000000058b90bfbe8d0260801c5b6504000000000083161561229b5770010000000000000000000002c5c85fdf460260801c5b650200000000008316156122c0577001000000000000000000000162e42fefa20260801c5b650100000000008316156122e55770010000000000000000000000b17217f7d00260801c5b648000000000831615612309577001000000000000000000000058b90bfbe70260801c5b64400000000083161561232d57700100000000000000000000002c5c85fdf30260801c5b6420000000008316156123515770010000000000000000000000162e42fef90260801c5b64100000000083161561237557700100000000000000000000000b17217f7c0260801c5b6408000000008316156123995770010000000000000000000000058b90bfbd0260801c5b6404000000008316156123bd577001000000000000000000000002c5c85fde0260801c5b6402000000008316156123e157700100000000000000000000000162e42fee0260801c5b640100000000831615612405577001000000000000000000000000b17217f60260801c5b638000000083161561242857700100000000000000000000000058b90bfa0260801c5b634000000083161561244b5770010000000000000000000000002c5c85fc0260801c5b632000000083161561246e577001000000000000000000000000162e42fd0260801c5b63100000008316156124915770010000000000000000000000000b17217e0260801c5b63080000008316156124b4577001000000000000000000000000058b90be0260801c5b63040000008316156124d757700100000000000000000000000002c5c85e0260801c5b63020000008316156124fa5770010000000000000000000000000162e42e0260801c5b630100000083161561251d57700100000000000000000000000000b172160260801c5b6280000083161561253f5770010000000000000000000000000058b90a0260801c5b62400000831615612561577001000000000000000000000000002c5c840260801c5b6220000083161561258357700100000000000000000000000000162e410260801c5b621000008316156125a5577001000000000000000000000000000b17200260801c5b620800008316156125c757700100000000000000000000000000058b8f0260801c5b620400008316156125e95770010000000000000000000000000002c5c70260801c5b6202000083161561260b577001000000000000000000000000000162e30260801c5b6201000083161561262d5770010000000000000000000000000000b1710260801c5b61800083161561264e577001000000000000000000000000000058b80260801c5b61400083161561266f57700100000000000000000000000000002c5b0260801c5b6120008316156126905770010000000000000000000000000000162d0260801c5b6110008316156126b157700100000000000000000000000000000b160260801c5b6108008316156126d25770010000000000000000000000000000058a0260801c5b6104008316156126f3577001000000000000000000000000000002c40260801c5b610200831615612714577001000000000000000000000000000001610260801c5b610100831615612735577001000000000000000000000000000000b00260801c5b6080831615612755577001000000000000000000000000000000570260801c5b60408316156127755770010000000000000000000000000000002b0260801c5b6020831615612795577001000000000000000000000000000000150260801c5b60108316156127b55770010000000000000000000000000000000a0260801c5b60088316156127d5577001000000000000000000000000000000040260801c5b60048316156127f5577001000000000000000000000000000000010260801c5b8461281657600f81901c6001600160701b03169050613fff82019150612845565b613ffe821161283b57600f81901c6001600160701b0316905081613fff039150612845565b600091613fee19011c5b60709190911b1760801b95945050505050565b60006102e2612878611031600160ff1b851861038c866103276002610496565b61032761289b6128886002610496565b61038c6113e3666f9c9e651c4480610496565b610e1a565b60006102e26129046128bb6113e3660b58c2126f4900610496565b6103918561038c6128e16128d86113e3660caaedbfa8a700610496565b600160ff1b1890565b6103918961038c6128fb6113e3663f4a728c19ce80610496565b6103918d61290a565b836107e7565b60006102e28261038c6129296128d86113e36640b43a04233100610496565b6103918661038c6113e3662f42c683f17c80610496565b60006020828403121561295257600080fd5b5035919050565b600080600080600060a0868803121561297157600080fd5b8535801515811461298157600080fd5b97602087013597506040870135966060810135965060800135945092505050565b6000602082840312156129b457600080fd5b81356001600160a01b03811681146110c757600080fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156102e2576102e26129cb565b80820281158282048414176102e2576102e26129cb565b634e487b7160e01b600052601260045260246000fd5b600082612a3e57634e487b7160e01b600052601260045260246000fd5b500490565b634e487b7160e01b600052600160045260246000fdfea26469706673582212202f4b517d86ed4855d9fcb3b65f162675580e09a7d215fd8a0d933ae2557192a664736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getOptionPrice(bool,uint256,uint256,uint256,uint256)": {
        "params": {
          "expiry": "expiry timestamp",
          "isPut": "is put option",
          "lastPrice": "current price",
          "strike": "strike price",
          "volatility": "volatility"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updateMinOptionPricePercentage(uint256)": {
        "params": {
          "_minOptionPricePercentage": "the new %"
        },
        "returns": {
          "_0": "whether % was updated"
        }
      },
      "updateVolatilityCap(uint256)": {
        "params": {
          "_volatilityCap": "the new volatility cap"
        },
        "returns": {
          "_0": "whether volatility cap was updated"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getOptionPrice(bool,uint256,uint256,uint256,uint256)": {
        "notice": "computes the option price (with liquidity multiplier)"
      },
      "updateMinOptionPricePercentage(uint256)": {
        "notice": "updates % of the price of asset which is the minimum option price possible"
      },
      "updateVolatilityCap(uint256)": {
        "notice": "updates volatility cap for an option pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 53,
        "contract": "contracts/OptionPricing.sol:OptionPricing",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3275,
        "contract": "contracts/OptionPricing.sol:OptionPricing",
        "label": "volatilityCap",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 3277,
        "contract": "contracts/OptionPricing.sol:OptionPricing",
        "label": "minOptionPricePercentage",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}